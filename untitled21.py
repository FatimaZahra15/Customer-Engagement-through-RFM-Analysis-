# -*- coding: utf-8 -*-
"""Untitled21.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RrDuD0y6MJr4WinDn-BnR38nXIeSZVHC
"""

import pandas as pd
import numpy as np
from datetime import datetime

# Load the dataset
file_path = '/content/music_streaming_rfm_data.xlsx'  # Adjust the path as necessary
music_streaming_data = pd.read_excel(file_path)

# Ensure 'Date of Last Stream' is a datetime type
music_streaming_data['Date of Last Stream'] = pd.to_datetime(music_streaming_data['Date of Last Stream'])

# Calculate RFM metrics
# Recency: Days since last stream
most_recent_date = music_streaming_data['Date of Last Stream'].max()
music_streaming_data['Recency'] = (most_recent_date - music_streaming_data['Date of Last Stream']).dt.days

# Frequency is already given as 'Number of Streams'
# Monetary is adapted as 'Total Streaming Time (hours)'

# Assign scores to Recency, Frequency, and Monetary values
r_labels = range(4, 0, -1)  # Higher scores for more recent activity
f_labels = range(1, 5)  # Higher scores for higher frequency
m_labels = range(1, 5)  # Higher scores for higher monetary value

r_quartiles = pd.qcut(music_streaming_data['Recency'], 4, labels=r_labels)
f_quartiles = pd.qcut(music_streaming_data['Number of Streams'], 4, labels=f_labels)
m_quartiles = pd.qcut(music_streaming_data['Total Streaming Time (hours)'], 4, labels=m_labels)

music_streaming_data['R'] = r_quartiles.values
music_streaming_data['F'] = f_quartiles.values
music_streaming_data['M'] = m_quartiles.values

# Create a combined RFM score
music_streaming_data['RFM_Score'] = music_streaming_data[['R', 'F', 'M']].sum(axis=1)

# Segment customers based on RFM score
def segment_customer(df):
    if df['RFM_Score'] >= 9:
        return 'High Value'
    elif df['RFM_Score'] >= 6:
        return 'Medium Value'
    else:
        return 'Low Value'

music_streaming_data['Segment'] = music_streaming_data.apply(segment_customer, axis=1)

# Display the first few rows to verify
music_streaming_data.head()

# Convert R, F, M scores and the combined RFM_Score to integers
music_streaming_data['R'] = music_streaming_data['R'].astype(int)
music_streaming_data['F'] = music_streaming_data['F'].astype(int)
music_streaming_data['M'] = music_streaming_data['M'].astype(int)
music_streaming_data['RFM_Score'] = music_streaming_data['RFM_Score'].astype(int)

# Display the data types to confirm changes
print(music_streaming_data.dtypes)

# Optionally, display the first few rows to check the dataset
music_streaming_data.head()

# Ensure R, F, M are integers
music_streaming_data['R'] = music_streaming_data['R'].astype(int)
music_streaming_data['F'] = music_streaming_data['F'].astype(int)
music_streaming_data['M'] = music_streaming_data['M'].astype(int)

# Calculate the combined RFM score
music_streaming_data['RFM_Score'] = music_streaming_data['R'] + music_streaming_data['F'] + music_streaming_data['M']

# Display the updated DataFrame to verify the RFM_Score
music_streaming_data[['Customer ID', 'R', 'F', 'M', 'RFM_Score']].head()

import matplotlib.pyplot as plt
import seaborn as sns

# Ensure seaborn style is used for nicer plots
sns.set(style="whitegrid")

# Count the number of customers in each segment
segment_counts = music_streaming_data['Segment'].value_counts().reset_index()
segment_counts.columns = ['Segment', 'Count']

# Create a bar plot for RFM segment distribution
plt.figure(figsize=(10, 6))
sns.barplot(x='Segment', y='Count', data=segment_counts, palette="coolwarm")
plt.title('RFM Segment Distribution')
plt.xlabel('Segment')
plt.ylabel('Number of Customers')
plt.xticks(rotation=45)
plt.show()

# Define a function to assign RFM Customer Segments based on RFM_Score
def assign_rfm_segment(row):
    if row['RFM_Score'] >= 9:
        return 'High Value'
    elif row['RFM_Score'] >= 6:
        return 'Medium Value'
    else:
        return 'Low Value'

# Apply the function to create a new column 'RFM_Customer_Segment'
music_streaming_data['RFM_Customer_Segment'] = music_streaming_data.apply(assign_rfm_segment, axis=1)

# Print the updated DataFrame with the new RFM segments
music_streaming_data[['Customer ID', 'R', 'F', 'M', 'RFM_Score', 'RFM_Customer_Segment']].head()

!pip install squarify

import squarify

# Aggregate total streaming time by RFM Customer Segment
segment_streaming_time = music_streaming_data.groupby('RFM_Customer_Segment')['Total Streaming Time (hours)'].sum().reset_index()

# Sort segments for better visualization
segment_streaming_time.sort_values(by='Total Streaming Time (hours)', ascending=False, inplace=True)

# Colors for different segments
colors = ['lightgreen', 'lightblue', 'orange']

# Plotting the treemap
plt.figure(figsize=(12, 8))
squarify.plot(sizes=segment_streaming_time['Total Streaming Time (hours)'],
              label=segment_streaming_time['RFM_Customer_Segment'],
              color=colors, alpha=0.8, text_kwargs={'fontsize':12})

plt.title('Treemap of RFM Customer Segments by Total Streaming Time')
plt.axis('off')  # Removes the axes for a cleaner look
plt.show()

# Filter the dataset for customers in the 'High Value' segment
champions_segment = music_streaming_data[music_streaming_data['RFM_Customer_Segment'] == 'High Value']

# Display the first few rows of the filtered dataset
champions_segment.head()

import plotly.graph_objects as go

# Assuming 'champions_segment' is your filtered DataFrame for High Value customers
# Let's create a histogram of "Total Streaming Time (hours)" for the Champions segment

fig = go.Figure()

# Add a histogram to the figure
fig.add_trace(go.Histogram(
    x=champions_segment['Total Streaming Time (hours)'],
    marker_color='indianred',  # You can change the color
    opacity=0.75
))

# Update the layout
fig.update_layout(
    title_text='Distribution of Total Streaming Time for Champions Segment',  # Title of the plot
    xaxis_title_text='Total Streaming Time (hours)',  # X-axis label
    yaxis_title_text='Count',  # Y-axis label
    bargap=0.2,  # Gap between bars of adjacent location coordinates
)

# Show the figure
fig.show()

import seaborn as sns

# Select only the RFM columns needed for the correlation matrix
champions_rfm_data = champions_segment[['Recency', 'Number of Streams', 'Total Streaming Time (hours)']]

# Calculate the correlation matrix
correlation_matrix = champions_rfm_data.corr()

# Visualize the correlation matrix
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix of RFM Values within Champions Segment')
plt.show()

# Set up the matplotlib figure for multiple plots
fig, axes = plt.subplots(1, 3, figsize=(18, 6), sharey=True)
fig.suptitle('Comparison of RFM Metrics Across Segments')

# Recency
sns.boxplot(ax=axes[0], x='RFM_Customer_Segment', y='Recency', data=music_streaming_data, order=["High Value", "Medium Value", "Low Value"])
axes[0].set_title('Recency')

# Frequency
sns.boxplot(ax=axes[1], x='RFM_Customer_Segment', y='Number of Streams', data=music_streaming_data, order=["High Value", "Medium Value", "Low Value"])
axes[1].set_title('Frequency')

# Monetary (Total Streaming Time)
sns.boxplot(ax=axes[2], x='RFM_Customer_Segment', y='Total Streaming Time (hours)', data=music_streaming_data, order=["High Value", "Medium Value", "Low Value"])
axes[2].set_title('Monetary (Total Streaming Time)')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])  # Adjust the layout to make room for the title
plt.show()

# Calculate the average R, F, and M scores for each RFM_Customer_Segment
average_rfm_scores = music_streaming_data.groupby('RFM_Customer_Segment').agg({
    'R': 'mean',
    'F': 'mean',
    'M': 'mean'
}).reset_index()

# Display the calculated averages for verification
average_rfm_scores

# Ensure R, F, and M scores are numeric
music_streaming_data[['R', 'F', 'M']] = music_streaming_data[['R', 'F', 'M']].apply(pd.to_numeric)

# Recalculate the average R, F, and M scores for each RFM_Customer_Segment
average_rfm_scores = music_streaming_data.groupby('RFM_Customer_Segment')[['R', 'F', 'M']].mean().reset_index()

# Display the recalculated averages for verification
average_rfm_scores

# Preparing data for the grouped bar chart
segments = list(average_rfm_scores['RFM_Customer_Segment'])
r_scores = list(average_rfm_scores['R'])
f_scores = list(average_rfm_scores['F'])
m_scores = list(average_rfm_scores['M'])

# Setting the positions and width for the bars
pos = list(range(len(segments)))
width = 0.25

# Plotting the bars
fig, ax = plt.subplots(figsize=(10, 6))

plt.bar(pos, r_scores, width, alpha=0.7, label='Recency', color='r')
plt.bar([p + width for p in pos], f_scores, width, alpha=0.7, label='Frequency', color='g')
plt.bar([p + width*2 for p in pos], m_scores, width, alpha=0.7, label='Monetary', color='b')

# Adding some aesthetics
ax.set_ylabel('Average Score')
ax.set_title('Average RFM Scores by Customer Segment')
ax.set_xticks([p + width for p in pos])
ax.set_xticklabels(segments)
plt.xlim(min(pos)-width, max(pos)+width*4)
plt.ylim([0, max(r_scores + f_scores + m_scores) * 1.1])

# Adding the legend and showing the plot
plt.legend(['Recency', 'Frequency', 'Monetary'], loc='upper left')
plt.grid()
plt.show()